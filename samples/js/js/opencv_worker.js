
importScripts('../lib/opencv.js');

function imageDataToMat(imageData) {
  var mat = new Module.Mat(imageData.height, imageData.width, Module.CV_8UC4);
  var view = Module.HEAPU8.subarray(mat.data);
  // XXX
  // Clone --- bad. We need this clone since mat.data must be located inside Emscripten HEAP.
  view.set(imageData.data);

  return mat;
}

// Clone mat.data into a data array which 
function matToImageData(mat) {
  var width = mat.size().get(1);
  var height = mat.size().get(0);
  var length = width * height * mat.elemSize();

  // XXX
  // Another clone -- even worse.... 
  // Why not just return mat.data back to main thread directly?
  // mat.data is belong to Module.HEAP, which is a ArrayBuffer, we can't just transfer 
  // Module.HEAP to main thread since we lost control of that HEAP here by doing taht, 
  // worker can not do anything without it. 
  // As a result, we need to clone We need this clone for transferable and memory management. 
  var matView = new Uint8ClampedArray(Module.HEAPU8.buffer, mat.data, length);
  var clonedBuffer = new ArrayBuffer(length);
  var clonedView = new Uint8ClampedArray(clonedBuffer);
  clonedView.set(matView);

  return new ImageData(clonedView, width, height);
}

var timeouts = [];

onmessage = function (event) {
  if (!!event.data.buffer) {
   WorkerCommandDispatcher.recieveSourceImage(event.data.buffer, event.data.size);
 }
 if (!!event.data.settings) {
  var settings = JSON.parse(event.data.settings);
  timeouts.forEach(function(v) {
   clearTimeout(v);
 });
  timeouts = [];

  timeouts.push(setTimeout(function() { 
   WorkerCommandDispatcher.receiveMessage(settings) 
 }, 0));
}
}

WorkerCommandDispatcher = {
  _image: null,
  // OpenCV.Filter.draw receive the message generated by this function.
  Filter: function (setting, imageData) {
    var source = imageDataToMat(imageData);
    var dest = new Module.Mat();

    // Algorithm
    var begin = performance.now();
    if (setting.type === "blur") {
      Module.blur(source, dest, [setting.kernel, setting.kernel], [-1,-1], Module.BORDER_DEFAULT);
    } else if (setting.type === "GaussianBlur") {
      Module.GaussianBlur(source, dest, [setting.kernel, setting.kernel], 0, 0, Module.BORDER_DEFAULT);
    } else if (setting.type === "medianBlur") {
      Module.medianBlur(source, dest, setting.kernel);
    } else {
      alert("Unsupport filter type.");
    }
    var duration = performance.now() - begin;

    var pout = matToImageData(dest);

    source.delete();
    dest.delete();

    // The format of the returning object.
    // [0] : the proceeded image.
    // [1] : an object to be packed into aMessage of postMessage.
    // [2] : a list to store transferable objects.  Generally, it 
    //   consists of ArrayBuffer objects.
   return [
   { imageData: pout, duration: duration },
   [ pout.data.buffer ]
   ];
 },

  // OpenCV.Histogram.draw receive the message generated by this function.
  Histogram: function (setting, imageData) {
    var source = imageDataToMat(imageData);
    var gray = new Module.Mat();

    Module.cvtColor(source, gray, Module.CV_RGBA2GRAY, 0);
    source.delete();

    var rgba = new Module.Mat();
    Module.cvtColor(gray, rgba, Module.CV_GRAY2RGBA, 0);
    var pout = matToImageData(rgba);

    rgba.delete();

    // Caculate histogram
    const bins = 100;
    var mask = new Module.Mat();
    var hist = new Module.Mat();
    var binSize = Module._malloc(4);
    var binView = new Int32Array(Module.HEAP8.buffer, binSize);
    binView[0] = bins;

    // Algorithm
    var begin = performance.now();
    Module.calcHist(gray, 1, 0, mask, hist, 1, binSize, 0, true, false);
    var duration = performance.now() - begin;

    var histImageData = matToImageData(hist);

    mask.delete();
    gray.delete();
    Module._free(binSize);

    return [
    { 
      imageData: pout,
      duration: duration,
        // Histogram image data.
        histogramImageData: histImageData,
        histogramBins: bins
      },
      [ 
     pout.data.buffer, 
     histImageData.data.buffer 
     ]
     ];
   },

  // OpenCV.Threshol.draw receive the message generated by this function.
  Threshold: function (setting, imageData) {
    // Generate threshold matrix.
    var source = imageDataToMat(imageData);
    var dest = new Module.Mat();

    // Algorithm
    var begin = performance.now();
    Module.threshold(source, dest, setting.threshold, setting.thresholdMax, setting.type);
    var duration = performance.now() - begin;

    // Generate threshold image data.
    var pout = matToImageData(dest);

    source.delete();
    dest.delete();

    return [
    { imageData: pout, duration: duration },
    [ pout.data.buffer ]
    ];
  },

  Morphology: function (setting, imageData) {
    var source = imageDataToMat(imageData);
    var element = Module.getStructuringElement(setting.shape, [setting.kernel, setting.kernel], 
      [(setting.kernel - 1) / 2, (setting.kernel - 1) / 2]);
    var dest = new Module.Mat();

    // Algorithm
    var begin = performance.now();
    if (setting.type === 'erode') {
      Module.erode(source, dest, element);
    } else {
      Module.dilate(source, dest, element);
    }
    var duration = performance.now() - begin;

    var pout = matToImageData(dest);

    dest.delete();
    element.delete();
    source.delete();

    return [
      { imageData: pout, duration: duration },
      [ pout.data.buffer ]
    ];
  },

  recieveSourceImage: function(buffer, size) {
    var view = new Uint8ClampedArray(buffer);
    this._image = new ImageData(view, size[0], size[1])
  },

  receiveMessage: function (settings) {
    // Main thread should sent image data to this worker thread before setting message.
    console.assert(this._image !== null);

    var imageData = this._image;
    var transferList = [];
    var aMessage = {}
    var self = this;
    settings.forEach(function (v) {
      var setting = JSON.parse(v);
      var algorithm = self[setting.id];
      if (!!algorithm) {
        var pair = algorithm(setting, imageData);
        console.assert(pair.length === 2);
        console.assert(!!pair[0] && !!pair[1]);

        // We have to put pack output of all algorithm and sent them in one single
        // postMessage call. To sent a message for each algorithm once by one, we
        // have to give up transferable list. But that introduce more memory copy then.
        imageData = pair[0].imageData;
        aMessage[setting.id] = pair[0];
        transferList.concat(pair[1]);
      }
    });

    postMessage(aMessage, transferList);
  }
};
